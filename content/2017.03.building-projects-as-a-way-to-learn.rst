Building software as a way to learn
###################################

:slug: building-software-as-a-way-to-learn
:date: 2017-03-15
:lang: en
:url: building-software-as-a-way-to-learn
:summary:
    Having multiple people working on a big project is not as easy as it seems.
    Here are some elements to move projects forward as a team.


Today, I realized that I've been working for Mozilla for three years
already.

I've learned a lot, and with the storage team we have been part of a
number of different projects:

- Firefox Hello: Building a WebRTC signaling service.
- MSISDN auth: Building a password less BrowserID authentication
  service using a phone number.
- Syncto: Browsing Firefox Sync using the Kinto protocol.
- Kinto: Building synchronization services with backup and sharing
  capabilities in mind.
- RemoteServiceWorker: Building a Firefox Service Worker that does
  heavy calculation in the cloud, to save battery life on mobile.
- WebPush channels: Building a PubSub on top of WebPush

While most of these projects have been built, deployed to production
and eventually decommissioned, some of them are still actively used by
Firefox users everyday.


How do you keep motivated building things that are thrown away?
===============================================================

Let's be honest: everything we build — cars, houses, and even software —
is meant to be eventually thrown away. That's why recycling is so
important.

The question is why do we keep building them nevertheless.

Our daily job is to help Mozilla make the web a safe place for users
and prevent their privacy from being compromised.

One way of doing so is to build software that empowers people to use
the Internet while being in charge of their own data.

When users give their data to big companies, they know they are giving
them to much power. In the meantime these companies are offering a
service that solve people problems, and they get addicted to it and
come back for more.

We alone cannot compete with companies that are spending millions of
dollars building great products to capture users.

However, we can build software that, on the one hand, is useful for
the Mozilla mission and enable us to fix Mozilla issues quickly while
building Firefox and, on the other hand, empowers developers to build
great software where users choose where they want to store and control
their data.

What matters rather than building software is the vision that this
software carries.

If you don't have a vision, what are you building? Sure, writing lines
of code is cheap and fast. You can build a prototype in two weeks and
iterate until you are happy with the Minimum Viable Product.

Note that, it might not be so cheap anymore when you start adding
documentation and maintenance costs.

The product might be used, and might get some traction for months or
even years but it will be eventually forgotten in a git repository
somewhere forever.

Writing software to solve problems is not enough, to keep motivated on
the long term. You need a greater goal than just writing code.

Knowing that, how do you keep motivated building things that are
thrown away?

Different people or communities might have different answers.

For us the answer is: As well as solving the problem, what can we
learn while building this solution that can be useful for us and for
our community to help us go faster and build more robust software
later.

For Mozilla the answer to that question is: How do I improve Firefox
so that people want to use it as their main browser?

Both answer lead to goals that we set to ourselves. We are using
software development to reach them.

Mozilla is calling that the True North, we are calling it a vision,
some other people might call it a utopia.

In both cases that vision should set the route of our ambition and give
people a aim to all look in the same direction.


How do you turn this vision into OKRs?
======================================

OKR means **Objectives and Key results**: it is a way to define what
you want to achieve in a tangible way and what you will be able to
mesure
`to see how effective you were <https://blog.betterworks.com/okrs-stretch-or-not-to-stretch/>`_.

It is also a way to cut your vision in steps and to move your vision
forward.


How do you set course for a vision?
===================================

To be able to define OKRs from your vision, you need to be able to find
the fastest way to get closer to your aim, however what we can learn
from sailing is that the fastest way is rarely the shortest.

At Mozilla, we have a vision that is written down in the
`Mozilla Manifesto <https://www.mozilla.org/en-US/about/manifesto/>`_.

Mitchell Baker does a great job making sure everyone at Mozilla stays
aligned with that vision.

However agreeing on the fastest way and turning the Mozilla vision
into OKRs is really challenging and even more when you have a thousand
people's opinion about it.

It's the board's job to set course every six months (or even less) on
what we should be focusing on for the next six months.

When this happens, it often means changing our course and killing
projects or at least putting them on the side if teams are turning to
new priorities.

At our level, we are driven by the use case. We have a vision of what
we want to build and we keep adding ideas in the backlog.

However we are not building anything until we have a proper use case
for it. As soon as we have a use case it is added to our Roadmap.

You endup not spending time on tasks you don't need and for each use
case you are getting closer to your goal even if it might not be the
way you'd taken initially.

You also don't have to support code that you don't use.

We even ended up removing features that were not used anymore.


Our luck is opensource
======================

The advantage we have at Mozilla, is that everything we do is
published as Free, Libre, Opensource Software, which means that, even
if, as Mozilla employees, we focus on something else, the work we've
done is still available for the community to care about it.

Thunderbird is an example of this. Mozilla stopped spending resources
on it in September 2007 but ten years later Mozilla Thunderbird is
still actively used by a large number of users every day.

When building software we solve complex issues and all the solutions
we have put together are really useful for other people who might need
to solve similar problems.

- Mozilla Persona lead the ground for Firefox Accounts and the Portier
  project.
- The Firefox Hello loop server is a good example of how to build a
  WebRTC signaling server.
- The RemoteServiceWorker project shows how to use Python 3 asyncio
  to handle a large pool of websockets using redis to route messages
  between them.


Prototyping as a way to learn
=============================
  
More than writing lines of code, we are researching solutions to
complex problems at scale and turning those solutions into production
ready experiments.

All this efforts are not lost because we learn a great deal from all
of them.

Whether it takes us a month or a year to build something, we are
learning.

But everything you learn is useful only if you share it.


Building software as a way to share
===================================

In one sentence, what matters the most is to build software to put
your vision in motion and to share what you've learned along the way.

Luckily, there are people that you need to inform about what you are
doing and learning about: your colleagues.

- You need to explain what you are trying to solve.
- You need to find out how to solve the issue and agree on the solution you are putting
  together.
- You need to take feedback to be able to choose the best solution
  even before having written a single line of code.

Conclusion
==========

As a conclusion, don't build software to build software, build it to
solve people problems. Set a long term goal, work toward that goal and
iterate. Do not be afraid of killing things that don't work.

In the meantime, make the process of building software a way to learn
new things and share what you've learn. Then you don't have to worry
about your project to be decommissioned because you've already got the
take aways of building it.
  
Make the process of build software a way to share what you've learned.
