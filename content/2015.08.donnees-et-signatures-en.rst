Sign collection to enforce data integrity
#########################################

:date: 2015-08-26
:summary: How to enforce data integrity to Kinto users using collection hash signature.
:slug: data-signature
:lang: en
:url: data-signature

.. note::

    Translated from the French by `RÃ©my Hubscher <https://twitter.com/Natim>`_.

Within the scope of the `Go Faster <https://wiki.mozilla.org/Firefox/Go_Faster>`_
project, we want to distribute minor Firefox updates more often than
just with major updates (which happens once every six weeks).

There are multiple kind of data that we will need to update on the client.
Among others, we would like to `update the SSL OneCRL (Control Revocation List)
<https://blog.mozilla.org/security/2015/03/03/revoking-intermediate-certificates-introducing-onecrl/>`_.

In that specific case, it is obviously very important to make sure
that all the fetched data are coming from Mozilla and that no records
are missing. So that we can be absolutely confident that nobody added
a valide certificate to the CRL or remove a revocated one.

A cryptographic signature can give us the guarantee that all the
records where fetched but it is still possible to prevent users to
completely access the service (*Chinese Great Firewall* for instance.)

This mecanism works in our specific use-cases of the OneCRL update
project, but it can also be useful to any future project that needs to
make sure that all records on a collection have been correctly synced.
We will probably need to re-use it to update other part of Firefox or
Fennec but you may also want to use it for your use-cases.

In order to distribute the data or meta-data associated with the files
that needs to be updated, we plan to use `Kinto
<https://kinto.readthedocs.org>`_. Kinto is a good fit because it can
easily be cached behind a CDN.

Also we don't want our user to trust either the CDN or the Kinto
server itself without checking. Somebody can attack the CDN or the
Kinto server and may add or remove records and update the CRL in a
wrong way. If you think about it is a horrible scenario.

Consider the following workflow:

- The person responsible to update the CRL, *the updater*, has got a
  private key (or even better `a HSM
  <https://en.wikipedia.org/wiki/Hardware_Security_Module>`_ which
  will enable her to sign a hash of the collection records;
- The corresponding public key ships with the client (Firefox or Fennec);
- *Hashing* and *signature* are done on client side to prevent some
  attacks vectors (if somebody can access the Kinto server for
  instance.)

The signing is a one-way operation called *hashing* that guarantee the
same result or the same input.


First data setup on Kinto
=========================

All the data are fetched from a *secured* source and converted into a
JSON collection. Each record have got a unique ID generated on client side.

For instance, we could have the following record:

.. code-block:: javascript

   {"id": "b7dded96-8df0-8af8-449a-8bc47f71b4c4",
    "fingerprint": "11:D5:D2:0A:9A:F8:D9:FC:23:6E:5C:5C:30:EC:AF:68:F5:68:FB:A3"}

Then the collection *hash* is digested, signed and then send to the Kinto server.
(See below for details)

The signature process is deported to a specific service in a sandbox
that make sure of the certificate security which is crucial in the
process.


How to validate data integrity?
===============================

First, we need to fetch the collection records as well as the hash and
the signature.

Then, we can validate that the hash signature is valid to make sure it
has been generated by a trusted source.

Finally we can digest our local collection hash to make sure it
matches the signed one.


Update the collection data
==========================

When you need to `CRUD
<https://en.wikipedia.org/wiki/Create,_read,_update_and_delete>`_
records of the collection, we need to make sure that our local
collection records matches the remove server ones and are valid.

Once we are confident that our collection update is valid, we can
digest the new collection hash and sign it.


How to digest the collection hash?
==================================

To digest the collection *hash*, you need a reproductible algorithm.

For instance one could be:

#. Sort records by their ids;
#. Serialize fields giving the value of each keys sorted by key;
#. Digest the *hash* of the records list serialization.

We do not know yet the exact algorithm that we will be using.

An interesting candidate could be the `JSON Web Signature
<https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41>`_
standard. Meanwhile, a naive Pythom implementation could look like
this:

.. code-block:: python

  import json
  import hashlib

  data = [
     {"id": "b7dded96-8df0-8af8-449a-8bc47f71b4c4",
      "fingerprint": "11:D5:D2:0A:9A:F8:D9:FC:23:6E:5C:5C:30:EC:AF:68:F5:68:FB:A3"},
     {"id": "dded96b7-8f0d-8f8a-49a4-7f771b4c4bc4",
      "fingerprint": "33:6E:5C:5C:30:EC:AF:68:F5:68:FB:A3:11:D5:D2:0A:9A:F8:D9:FC"}]

  m = hashlib.sha256()
  m.update(json.dumps(data, sort_keys=True))
  collection_hash = m.hexdigest()

Here is a little sketch to summarize:

.. image:: {filename}/images/kinto-signing.jpg
    :align: center
